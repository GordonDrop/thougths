\#сети

# Протоколы верхнего уровняю. HTTP/2

## Цели

**Главные цели протокола** уменьшение задержки с помощью:
- **Мультеплексирование** запросов и ответов
- минимизация затрат с помощью эфф-ой **компресии HTTP заголовков**
- Поддержка **приоритизации запросов и server push**

Для реализации этих требований необходимо сделат улучешния в большей части проотокола таких **flow control**, **error handling**, and **upgrade mechanisms**.

HTTP/2 меняет как форматируются и передаются данный между клиетом и сервером, каждый из к. управляет процессом и прячет сложность от наших приложений под новым framing layer.

**Важно!** HTTP/2 только расширяет пред версию протокола. Семантика и главные концепты остались прежними (методы, статусы, URI, заголовки).

## Binary framing layer

Ядро всех улучшений производительности - новый binary framing layer, который диктует как  HTTP сообщения инкапсулируются и передаются между клиентом и сервером.

![binary_framing_layer](https://developers.google.com/web/fundamentals/performance/http2/images/binary_framing_layer01.svg)

"Слой" это новый механизм между интрфейсом соекта и АПИ более выского уровня(приложения). Все коммуникации разделены на более маленькие сообщения и фреймы, каждое из которых закодировано в бин фомрате. В рез-ту и клиент и сервер обязаны исп-ть новый мех-зм.

## Стримы, сообщения и фреймы

**Стрим** - двунаправленный поток байтов внутри уст-го соединения, который может переносить 1+ сообщений

**Сообщение** - полная послед-ть фреймов, которые мапяться к лог запросу или ответу сообщения

**Фрейм, кадр** - Наимельчайший юнит коммуникации в HTTP/2, каждый содержит заголовок фрейма, к как мин id к каком потоку относиться кадр.

Суммируем:
- Все комм-ции происходят через tcp соединение, которое может передавать люб кол-во двунаправленых потоков
- Кажд поток имеет уник id, и опц-ю инф-цию о приоритете
- Кажд сообщение это лог HTTP сообщение, такое как запрос, ответ, к может состоять из 1+ кадра
- Кадр - это мин юнит общения, к. несет специфич. тип данных, напр, заголовки, данные сообщения и тп. Кадры могут чередоваться в потоке и пересобираться через встроеный id потока, в заголовке кадра

![streams_messages_frames](https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg)

## Мультеплексированние запроса и ответа

Новый binary framing layer убирает ограничения HTTP/1: для паралл запросов требуется неск соедниений. Т.о. HTTP/1 удостоверяется, что только один запрос может быть доставление за одно соединение.

![multiplexing](https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg)

На картинке неск потоков в рамках одного соединения. Клиент отправляетс stream 5, а сервер еще два паралелльно.

**Преимущества:**
- Чередование запросов и ответов парал-но без блокировки
- Одно соед-е для доставки множ-ва запросов и ответов парал-но
- Избавление от ненужных workarounds(конкатенация файлов, спрайты, доменный шардинг)
- ум-е задержки и более лучшая утилизация пропускной способности сети
- ДР...

## Приоритезация потоков

Так сообщения разделены на фреймы, а фреймы мультеплексированы в разные потоки, то становиться важным в каком порядке доставляются данные. Каждый поток может иметь вес:

- Кажд Потоку может быть назначен вес int 1-256
- Кажд Потоку может быть явно указано от какого потока он зависит

Это позволяет клиент строить дерево приоритетов, к. опред-т как клиень предпочитает получать сообщения. Это позволяет сделать оптимизацию по выделению ресурсов ЦПУ и памяти и др ресурсов.

## Одно соединение на origin

Переисполз-е того же соед-я позвоялет более эф-но переиспользовать TCP соединение. (Ум-е RTT, TLS handshakes)

## Flow control 
Механизм предотварщения отправки слишком большго кол-ва данных, т.о. что получать не сможет данные обработать.

- Flow control направленный. Кажд получательь может выбрать размер для потока
- Не может быть отключен
- Hop by hop

## Server push

Возможност отправить клиенту неск доп ответов в ответо на один запрос. Позволяет уменьшить задержку, сервер пушить ресурсы, к. часто запрашиваются с текущием, aot(ahead of time).

## Header compression

Кодирование заголовков через статич код Хаффмана

**Источник** 
[https://developers.google.com/web/fundamentals/performance/http2/](https://developers.google.com/web/fundamentals/performance/http2/)

## h2 на мобильных

--- Главная проблема h1 - использование одного соеднинения на один запрос, что увеличило затраты времени на постоянное установление новых соед-й на каждый запрос.

h2 решает это с помощью утилизации одного пост соеднинения. Несколько сообщения обрабатываются в очереди. После отправки сообщение есть небольшое окно, к. ждет отправитель, затем снова делает запрос.