\#сети

# Протоколы верхнего уровняю. HTTP/2

## Цели

**Главные цели протокола** уменьшение задержки с помощью:
- **Мультеплексирование** запросов и ответов
- минимизация затрат с помощью эфф-ой **компресии HTTP заголовков**
- Поддержка **приоритизации запросов и server push**

Для реализации этих требований необходимо сделат улучешния в большей части проотокола таких **flow control**, **error handling**, and **upgrade mechanisms**.

HTTP/2 меняет как форматируются и передаются данный между клиетом и сервером, каждый из к. управляет процессом и прячет сложность от наших приложений под новым framing layer.

**Важно!** HTTP/2 только расширяет пред версию протокола. Семантика и главные концепты остались прежними (методы, статусы, URI, заголовки).

## Binary framing layer

Ядро всех улучшений производительности - новый binary framing layer, который диктует как  HTTP сообщения инкапсулируются и передаются между клиентом и сервером.

![binary_framing_layer](https://developers.google.com/web/fundamentals/performance/http2/images/binary_framing_layer01.svg)

"Слой" это новый механизм между интрфейсом соекта и АПИ более выского уровня(приложения). Все коммуникации разделены на более маленькие сообщения и фреймы, каждое из которых закодировано в бин фомрате. В рез-ту и клиент и сервер обязаны исп-ть новый мех-зм.

## Стримы, сообщения и фреймы

**Стрим** - двунаправленный поток байтов внутри уст-го соединения, который может переносить 1+ сообщений

**Сообщение** - полная послед-ть фреймов, которые мапяться к лог запросу или ответу сообщения

**Фрейм, кадр** - Наимельчайший юнит коммуникации в HTTP/2, каждый содержит заголовок фрейма, к как мин id к каком потоку относиться кадр.

Суммируем:
- Все комм-ции происходят через tcp соединение, которое может передавать люб кол-во двунаправленых потоков
- Кажд поток имеет уник id, и опц-ю инф-цию о приоритете
- Кажд сообщение это лог HTTP сообщение, такое как запрос, ответ, к может состоять из 1+ кадра
- Кадр - это мин юнит общения, к. несет специфич. тип данных, напр, заголовки, данные сообщения и тп. Кадры могут чередоваться в потоке и пересобираться через встроеный id потока, в заголовке кадра

![streams_messages_frames](https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg)

## Мультеплексированние запроса и ответа

Новый binary framing layer убирает ограничения HTTP/1: для паралл запросов требуется неск соедниений. Т.о. HTTP/1 удостоверяется, что только один запрос может быть доставление за одно соединение.

![multiplexing](https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg)

На картинке неск потоков в рамках одного соединения. Клиент отправляетс stream 5, а сервер еще два паралелльно.

**Преимущества:**
- Чередование запросов и ответов парал-но без блокировки
- Одно соед-е для доставки множ-ва запросов и ответов парал-но
- Избавление от ненужных workarounds(конкатенация файлов, спрайты, доменный шардинг)
- ум-е задержки и более лучшая утилизация пропускной способности сети
- ДР...

## Приоритезация потоков

Так сообщения разделены на фреймы, а фреймы мультеплексированы в разные потоки, то становиться важным в каком порядке доставляются данные. Каждый поток может иметь вес:

- Кажд Потоку может быть назначен вес int 1-256
- Кажд Потоку может быть явно указано от какого потока он зависит

Это позволяет клиент строить дерево приоритетов, к. опред-т как клиень предпочитает получать сообщения. Это позволяет сделать оптимизацию по выделению ресурсов ЦПУ и памяти и др ресурсов.

## Одно соединение на origin

Переисполз-е того же соед-я позвоялет более эф-но переиспользовать TCP соединение. (Ум-е RTT, TLS handshakes)

## Flow control 
Механизм предотварщения отправки слишком большго кол-ва данных, т.о. что получать не сможет данные обработать.

- Flow control направленный. Кажд получательь может выбрать размер для потока
- Не может быть отключен
- Hop by hop

## Server push

Возможност отправить клиенту неск доп ответов в ответо на один запрос. Позволяет уменьшить задержку, сервер пушить ресурсы, к. часто запрашиваются с текущием, aot(ahead of time).

## Header compression

Кодирование заголовков через статич код Хаффмана

**Источник** 
[https://developers.google.com/web/fundamentals/performance/http2/](https://developers.google.com/web/fundamentals/performance/http2/)

## h2 на мобильных

Наиб влияние на скорость передачи влиет задержка на уст-е соед-я после ув-я скорости передачи данных по моб сети 5+mbps.

Природа задержки в моб сетях: девайс должен соединиться с радио вышкой для получения разрешения, чтобы соед-ся с интернетом. Это процесс контролирует Radio Resource Controller (RRC) - он отвечает за то сколько, когда ширины канала кто может получить. Моб девайсам требуется слишком много батареи, чтобы держать такое пост контакт с RRC. Вместо этого тлф должен делать новые запросы каждый раз при соед-и с интернетом. Сегодня это может занимать 10-100ms c 3g.

Как указывает Илья Григорик только превая половина этого прцесса была улучшена. После соед-я с RRC сигнал должен быть передан через перваый Package Gateway, затем Serving Gateway. Адаптация новых моб сетей умен вермя задержки на соед с башней, все что после все еще проблема.

Главная проблема h1 - использование одного соеднинения на один запрос, что увеличило затраты времени на постоянное установление новых соед-й на каждый запрос. Время ожидания сети с h1 было слишком велико. h1 решало проблему просто говоря серверам держать соед как только был отправлен посл пакет. С пост соедн-ем нет необходиости уст новое соед. Кажд такое соед позволяет передавать неск соединений (после отправки сообщение, ждем небольшое окно времении и отправляем след). До тех пор пока сообщения завершаются в порядке отправления, нет потерь инф-ции. 

Но такой метод страдает от “Head-of-line blocking” (HOL blocking) - весь процесс может быть замедлен при потери одного из пакетов. Совр браузеры открывают неск соед, чтобы решить эту проблему.

h2 решает HOL blocking с помощью мультеплексирования. Несколько сообщения обрабатываются в очереди. Главный плюс - при потери пакета, поток продолжит передавать фреймы, а часть утеренного потока будет хранится в буфере, пока утерянный фрейм не появиться. TCP также требует, чтобы пакеты обрабатывались по порядку, любое приложение, кю ждет поток будет ждать. Это тоже HOL blocking, но это уже требование TCP обрабатывать пакеты по порядку. След задержка из-за потери пакета все еще присутствует, но уже уровнем ниже.

Тестирование h2 и h1 в моб сетях показывает, что их произв-ть зависит от набора условий сети, кол-ва и размера передаваемых объектов, и размера веб страниц.

Исследование показало слабость h2: потеря пакетов из-за перегруженности сети. Поэтому когда h1 использует неск соед-й потеря пакетов блокирует только одно соед-е. Ясно, что моб сети должны быть одним из главных фокусов разработки h2. Требуется переработа TCP. Единственная ему альтернатива это UDP.

Источник:
[https://www.gobfw.com/web-development/mobile-networks-http2-on-hold/](https://www.gobfw.com/web-development/mobile-networks-http2-on-hold/)

TODO: 
https://2019.codefest.ru/lecture/1458